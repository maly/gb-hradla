### 20.3.2 {#20-3-2}

Vyjádření logických výrazů

Víme, že C (= E) má být 1 pro kombinace 011, 100 a 101\. Pro kombinace 000, 001 a 010 má být 0\. Pro ostatní kombinace je nám to jedno, protože ty nenastanou. Jak takovéhle zadání převést na logický výraz?

Vidíme, že C je 1 tehdy, když je QD (nejvyšší bit) v logické 1\. Toto pravidlo pokrývá kombinace 100 a 101\. Zapíšeme si:

C = E = QD ...

a pokračujeme dál. Musíme totiž pokrýt kombinaci 011.

Tu bychom mohli vyjářit jako „NOT QD AND QC AND QB“ – platí, pokud je QD 0, QC 1 a QB taky 1\. Jenže my nepotřebujeme úplně přesně odlišit 011 a 111 (protože ta druhá nenastane). Můžeme tedy říct, že je nám stav QD ukradený. Pomůže to nějak? Pomůže! Kombinaci něco-1-1 můžeme vyjádřit jako „pokud nastane QB a zároveň QC“. Spojka „a“ znamená funkci AND. QB AND QC bude platit pro kombinace 011 a 111, ale to nám nevadí, protože 111 nenastane.

No a výsledek tedy je: C je 1, pokud:

je QD rovno 1

nebo

je QC=1 a QB=1

Tedy:

C = E = QD OR (QC AND QB)

Ptáte se, jestli existuje způsob, jak z tabulky zjistit logický výraz? Existuje jich několik. Jeden z nich, asi nejjednodušší pro funkce tří nebo čtyř bitů, je takzvaná Karnaughova mapa. Do té se teď nechci pouštět, ale myslím, že se k ní ještě vrátím, alespoň v příloze.

Máme tedy sérii výrazů. První vyjádříme pomocí hradla NOT, druhý pomocí třívstupového OR, třetí pomocí dvouvstupového AND, a čtvrtý pomocí dvojice AND-OR.

To znamená, že budeme potřebovat dvouvstupové AND (jeden obvod), třívstupové OR (druhý obvod), dvojici AND-OR (buď třetí obvod, nebo využijeme jedno hradlo AND z prvního obvodu a jedno hradlo OR z druhého obvodu), no a invertor. A ten už tam naštěstí máme.

Trošku problém bude u toho hradla OR. V základní řadě 74xx nejsou třívstupová hradla OR. Existují v řadě 7440xx, což jsou takové TTL náhrady za CMOS obvody. Tam je k dispozici obvod 744075 – trojice třívstupových hradel OR.

Ovšem naštěstí existuje takový technický hack, který nám ušetří hradla OR, a kterému se říká